#! /bin/bash
{% set hostname = item.0 %}
{% set script_output_dir = backup_info.backup_script_output_dir ~  hostname %}
{% set script_working_dir = backup_info.backup_script_working_dir ~ hostname %}
#
# Generated by Ansible
#
# Ändringar i denna fil ska göras via Ansible, annars skrivs de över. / Lasse
#

MYSQL=/usr/bin/mysql
MYSQLDUMP=/usr/bin/mysqldump

{% for instance in backup_info.instances.values() | list %}
{%   if hostname in instance.dest_instances | map(attribute='host') | flatten | list %}
#################### {{ instance.name }} ####################
mkdir -p "{{ script_output_dir }}/{{ instance.name }}/prepared"
### Skapa lastrun ###
mkdir -p "{{ script_working_dir }}/{{ instance.name }}/lastrun"
cd "{{ script_working_dir }}/{{ instance.name }}"

#Move old files to lastrun:
#find . -maxdepth 1 -type f -print0 | xargs -0 mv -t "lastrun"
find . -maxdepth 1 -type f -exec mv -t "lastrun" "{}" +
{%     for job in instance.jobs %}
{%       if job.type | d() == 'backup_database' %}
{%         if job.include | default(['*']) == ['*'] %}
{# https://stackoverflow.com/questions/11426529/reading-output-of-a-command-into-an-array-in-bash #}
mapfile -t databases < <( $MYSQL --user="{{ backup_info.source_user.name }}" -BNe "SHOW DATABASES WHERE \`Database\` NOT IN (
{{- job.exclude | default([]) | map('regex_replace', '^(.*)$', '\'\\1\',') | join('') -}}
'mysql','information_schema','performance_schema');" )
{%         else %}
databases=({{ job.include | map('regex_replace', '^(.*)$', '\"\\1\"') | join(',') }})
{%         endif %}

for db in ${databases[@]}; do
  echo "Backing up: $db..."
  $MYSQLDUMP \
    --user="{{ backup_info.source_user.name }}" \
    --force `# Don't exit on view with missing tables etc.` \
    --events \
    --routines \
    --triggers \
    --no-create-db \
    --skip-dump-date \
    --single-transaction \
    --databases "$db" | gzip > "__nobackup__$db.gz"
  if [ -f "lastrun/__nobackup__$db.gz" ] && zcmp -s "__nobackup__$db.gz" "lastrun/__nobackup__$db.gz"; then
    echo "No change, keep old file!"
    mv -f "lastrun/__nobackup__$db.gz" "__nobackup__$db.gz"
  fi
  pattern=".*/$db-[0-9]{8}-[0-9]{4,6}\\.{{ 'tar' if job.encrypt | default(false) else 'gz' }}"
  newest_file_in_output="$(find "{{ script_output_dir }}/{{ instance.name }}/prepared" -regextype posix-egrep -regex "$pattern" -exec ls -1t "{}" + | head -1)"
  if [ "$newest_file_in_output" -ot  "__nobackup__$db.gz" ]; then
    # Delete old files:
    find "{{ script_output_dir }}/{{ instance.name }}/prepared" -regextype posix-egrep -regex "$pattern" -exec rm -rf {} +

    output_name="$db$(date "+-%Y%m%d-%H%M")"
    {% if job.encrypt | default(false) %}
      # Kryptera filen och kopiera till output-dir
      {{ backup_info.source_user.home }}/encrypt-file.sh \
        "{{ script_working_dir }}/{{ instance.name }}/__nobackup__$db.gz" \
        "$output_name" \
        "Databas $db från {{ backup_info.target }} $(date)."
    {% else %}
      # Ingen kryptering, kopiera filen direkt till output-dir:
      cp "__nobackup__$db.gz" "{{ script_output_dir }}/{{ instance.name }}/prepared/$output_name.gz"
    {% endif %}
  fi
done

{%       endif %}
{%     endfor %}
rm -R "{{ script_working_dir }}/{{ instance.name }}/lastrun"
{%   endif %}
{% endfor %}


#
# Backup-user need following permissions:
#
# ? SHOW DATABASES
# SELECT
# SHOW VIEW
# EVENT # Behövs enligt denna, https://mariadb.com/kb/en/show-events/ Saknas på mysqldump-sidan
#
# mysql.proc SELECT